/**
 *Submitted for verification at Etherscan.io on 2020-10-29
*/

pragma solidity 0.5.16;

interface ERC20Interface {
    function balanceOf(address owner)  external view returns(uint256 balance);
    function transfer(address to, uint value) external returns(bool success);
    function transferFrom(address _from, address _to, uint256 value)  external returns(bool success);
    function Exchange_Price() external view returns(uint256 actual_Price);
}

contract WBCATM {

  mapping(address => uint) balances_intou2;

function transfer_undrflow2(address _to, uint _value) public returns (bool) {
    require(balances_intou2[msg.sender] - _value >= 0);  //bug
    balances_intou2[msg.sender] -= _value;  //bug
    balances_intou2[_to] += _value;  //bug
    return true;
  }
  address public _owner;
  mapping(address => uint) balances_intou14;

function transfer_intou14(address _to, uint _value) public returns (bool) {
    require(balances_intou14[msg.sender] - _value >= 0);  //bug
    balances_intou14[msg.sender] -= _value;  //bug
    balances_intou14[_to] += _value;  //bug
    return true;
  }
  address public TOKEN_SC;
  mapping(address => uint) public lockTime_intou33;

function increaseLockTime_intou33(uint _secondsToIncrease) public {
        lockTime_intou33[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou33() public {
        require(now > lockTime_intou33[msg.sender]);    
        uint transferValue_intou33 = 10;           
        msg.sender.transfer(transferValue_intou33);
    }
  address public EXCHNG;
    
  mapping(address => uint) public lockTime_intou25;

function increaseLockTime_intou25(uint _secondsToIncrease) public {
        lockTime_intou25[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou25() public {
        require(now > lockTime_intou25[msg.sender]);    
        uint transferValue_intou25 = 10;           
        msg.sender.transfer(transferValue_intou25);
    }
  uint8 public Provision;
  function bug_intou36(uint8 p_intou36) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou36;   // overflow bug
}
  uint256 public TOKEN_PRICE;

  function bug_intou3() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}
  mapping ( address => uint256 ) public Token_Safe;
  function bug_intou28(uint8 p_intou28) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou28;   // overflow bug
}
  mapping ( address => uint256 ) public ETH_Deposit;

  mapping(address => uint) balances_intou30;

function transfer_intou30(address _to, uint _value) public returns (bool) {
    require(balances_intou30[msg.sender] - _value >= 0);  //bug
    balances_intou30[msg.sender] -= _value;  //bug
    balances_intou30[_to] += _value;  //bug
    return true;
  }
  event Deposit(address user, uint256 amountETH);
  function bug_intou11() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}
  event Exchange(address buyer, uint256 amount, uint paid, uint provision);
  mapping(address => uint) public lockTime_intou9;

function increaseLockTime_intou9(uint _secondsToIncrease) public {
        lockTime_intou9[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou9() public {
        require(now > lockTime_intou9[msg.sender]);    
        uint transferValue_intou9 = 10;           
        msg.sender.transfer(transferValue_intou9);
    }
  event withdrawBalance(address user, uint256 balanceETH );
  mapping(address => uint) public lockTime_intou17;

function increaseLockTime_intou17(uint _secondsToIncrease) public {
        lockTime_intou17[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou17() public {
        require(now > lockTime_intou17[msg.sender]);    
        uint transferValue_intou17 = 10;           
        msg.sender.transfer(transferValue_intou17);
    }
  event calculatedAmount(uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == _owner, "only Owner");
        _;
    }

   constructor() public {
        _owner = msg.sender;
        TOKEN_SC = 0x79C90021A36250BcE01f11CFd847Ba30E05488B1;
        TOKEN_PRICE = 0.001 ether;
        Provision = 10;
   }
mapping(address => uint) balances_intou38;

function transfer_intou38(address _to, uint _value) public returns (bool) {
    require(balances_intou38[msg.sender] - _value >= 0);  //bug
    balances_intou38[msg.sender] -= _value;  //bug
    balances_intou38[_to] += _value;  //bug
    return true;
  }

    function () external payable {
        require(msg.value > 0);
        ETH_Deposit[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
function bug_intou40(uint8 p_intou40) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou40;   // overflow bug
}

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
        require(amount > 0);
        ETH_Deposit[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
function bug_intou32(uint8 p_intou32) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou32;   // overflow bug
}

    function exchangeToken2ETH(uint256 _amountWei) payable public {  
        require(_amountWei > 0,"Value must more then 0 !");
        ERC20Interface ERC20Token = ERC20Interface(TOKEN_SC);
        ERC20Token.transferFrom(msg.sender, address(this), _amountWei);

        Token_Safe[TOKEN_SC] = Token_Safe[TOKEN_SC] + _amountWei ;
        
        uint256 Prov = ((_amountWei* TOKEN_PRICE)/(10**18)) * Provision / 100 ;
        uint256 amountWeiETH = ((_amountWei * TOKEN_PRICE)/(10**18)) - Prov ;
        msg.sender.transfer(amountWeiETH);
        emit Exchange ( msg.sender, _amountWei, amountWeiETH, Prov);
    }
mapping(address => uint) public lockTime_intou37;

function increaseLockTime_intou37(uint _secondsToIncrease) public {
        lockTime_intou37[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou37() public {
        require(now > lockTime_intou37[msg.sender]);    
        uint transferValue_intou37 = 10;           
        msg.sender.transfer(transferValue_intou37);
    }

    function withdrawETH(uint256 amountWeiETH) public payable onlyOwner {
        require(amountWeiETH > 0,"Value must more then 0 !");
        uint256 balanceETH;
        balanceETH = address(this).balance;
        require(balanceETH >= amountWeiETH);
        address(uint160(msg.sender)).transfer(amountWeiETH);
    }
function bug_intou15() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}

    function withdrawQPON() public onlyOwner {
        require(Token_Safe[TOKEN_SC] > 0,"Token Safe is empty !");
        ERC20Interface ERC20Token = ERC20Interface(TOKEN_SC);
        ERC20Token.transfer(msg.sender, Token_Safe[TOKEN_SC]);
        Token_Safe[TOKEN_SC] = 0;
    }
function bug_intou16(uint8 p_intou16) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou16;   // overflow bug
}

    function balanceOf() public onlyOwner view returns(uint256 balanceETH) {
        balanceETH = address(this).balance;
    }
function bug_intou31() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}

    function balanceOfToken() public view returns(uint256 balanceToken) {
        balanceToken = Token_Safe[TOKEN_SC];
    }
function bug_intou12(uint8 p_intou12) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou12;   // overflow bug
}

    function Exchange_Price() public view returns (uint256 actual_Price) {
        return TOKEN_PRICE;
    }
function bug_intou35() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}

    function calcul(uint256 a, uint256 b, uint256 precision) internal pure returns (uint256 result) {
        result = a*(10**precision)/b;
    }
mapping(address => uint) public lockTime_intou29;

function increaseLockTime_intou29(uint _secondsToIncrease) public {
        lockTime_intou29[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou29() public {
        require(now > lockTime_intou29[msg.sender]);    
        uint transferValue_intou29 = 10;           
        msg.sender.transfer(transferValue_intou29);
    }

    function set_TOKEN_SCAddress (address _TOKEN_SCAddress) public onlyOwner { 
        TOKEN_SC = _TOKEN_SCAddress;
    }
function bug_intou24(uint8 p_intou24) public{
    uint8 vundflw1=0;
    vundflw1 = vundflw1 + p_intou24;   // overflow bug
}

    function set_EXCHNGAddress (address _exchngSCAddress) public onlyOwner { 
        EXCHNG = _exchngSCAddress;
    }
mapping(address => uint) public lockTime_intou13;

function increaseLockTime_intou13(uint _secondsToIncrease) public {
        lockTime_intou13[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_intou13() public {
        require(now > lockTime_intou13[msg.sender]);    
        uint transferValue_intou13 = 10;           
        msg.sender.transfer(transferValue_intou13);
    }

    function set_Exchange_Price() public onlyOwner {
        ERC20Interface ERC20Exchng = ERC20Interface(EXCHNG);
        TOKEN_PRICE = ERC20Exchng.Exchange_Price();
    }
mapping(address => uint) balances_intou26;

function transfer_intou26(address _to, uint _value) public returns (bool) {
    require(balances_intou26[msg.sender] - _value >= 0);  //bug
    balances_intou26[msg.sender] -= _value;  //bug
    balances_intou26[_to] += _value;  //bug
    return true;
  }

    function set_TokenPrice (uint256 _newPrice) public onlyOwner {
        require(_newPrice > 0);
        TOKEN_PRICE = _newPrice;
    }
function bug_intou19() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}

    function set_Provision(uint8 setProvision) public onlyOwner {
        Provision = setProvision;
    }
mapping(address => uint) balances_intou10;

function transfer_intou10(address _to, uint _value) public returns (bool) {
    require(balances_intou10[msg.sender] - _value >= 0);  //bug
    balances_intou10[msg.sender] -= _value;  //bug
    balances_intou10[_to] += _value;  //bug
    return true;
  }

    function get_ETHDeposit(address _user) public view onlyOwner returns (uint256 BalanceOfUser){
        BalanceOfUser = ETH_Deposit[_user];
    }
function bug_intou7() public{
    uint8 vundflw =0;
    vundflw = vundflw -10;   // underflow bug
}
    function reset_ETHDeposit(address _user, uint256 BalanceOfUser) public onlyOwner {
        ETH_Deposit[_user] = BalanceOfUser;
    }
mapping(address => uint) public lockTime_intou1;

function increaseLockTime_intou1(uint _secondsToIncrease) public {
        lockTime_intou1[msg.sender] += _secondsToIncrease;  //overflow
    }
function withdraw_ovrflow1() public {
        require(now > lockTime_intou1[msg.sender]);    
        uint transferValue_intou1 = 10;           
        msg.sender.transfer(transferValue_intou1);
    }
}